/************************************************************
************************************************************/
#include <stdio.h>

#include "DigitalFilter.h"

/************************************************************
***********************************************************/
static const double k_ave = 0.001;

/************************************************************
************************************************************/

/******************************
******************************/
SOUND_FILTER::SOUND_FILTER()
: iir2_through(1, 0, 0, 1, 0, 0, true)
, iir4_LPF(	1, -1.9922922037219, 0.992391409119, 2.4801349279354E-5, 4.9602698558708E-5, 2.4801349279354E-5,
			1, -1.9816308588703, 0.98172953338995, 2.466862992375E-5, 4.93372598475E-5, 2.466862992375E-5, 
			true) // -70Hz
, iir4_BPF(	1, -1.3395593345608, 0.67160343961376, 0.17230071067711, 0, -0.17230071067711,
			1, -1.7220570304062, 0.81338273230981, 0.20230018413371, 0, -0.20230018413371,
			true) // 2k - 5k
, iir4_LPF_forSoundSync(	1, -1.9922922037219, 0.992391409119, 2.4801349279354E-5, 4.9602698558708E-5, 2.4801349279354E-5,
							1, -1.9816308588703, 0.98172953338995, 2.466862992375E-5, 4.93372598475E-5, 2.466862992375E-5, 
							true) // -70Hz
{
}

/******************************
******************************/
SOUND_FILTER::~SOUND_FILTER()
{
}

/******************************
******************************/
void SOUND_FILTER::x_in(float val)
{
	iir2_through.x_in(val);
	iir4_LPF.x_in(val);
	iir4_BPF.x_in(val);
	iir4_LPF_forSoundSync.x_in(val);
}

/******************************
******************************/
double SOUND_FILTER::get_y(int VolType)
{
	if(NUM_VOL_TYPES <= VolType) { ERROR_MSG(); ofExit(); return; }
	
	switch(VolType){
		case VOL_THROUGH:
			return iir2_through.get_y();
			
		case VOL_LPF:
			return iir4_LPF.get_y();
			
		case VOL_BPF:
			return iir4_BPF.get_y();
			
		case VOL_SOUNDSYNC:
			return iir4_LPF_forSoundSync.get_y();
			
		default:
			ERROR_MSG();
			ofExit();
			return -1;
	}
}

/******************************
explanation
	_xを入力し、4次のIIR filterを通った後のy[0]まで算出.
******************************/
double IIR_4::x_in(double _x)
{
	return iir2_1.x_in(iir2_0.x_in(_x));
}

/******************************
explanation
	移動平均後の y を出力.
******************************/
double IIR_4::get_y()
{
	/********************
	Is_move_aveの設定はコンストラクタで設定済み
	********************/
	return iir2_1.get_y();
}

/******************************
explanation
	_xを入力し、2次のIIR filterを通った後のy[0]まで算出.
******************************/
double IIR_2::x_in(double _x)
{
	/********************
	********************/
	for(int i = NUM_HISTORY - 1; 0 < i; i--){
		x[i] = x[i - 1];
		y[i] = y[i - 1];
	}
	x[0] = _x;
	y[0] = -Cb * y[1] - Cc * y[2] + Cd * x[0] + Ce * x[1] + Cf * x[2];
	
	/********************
	********************/
	/********************
	********************/
	if(Is_move_ave)	last_y = (1 - k_ave) * last_y + k_ave * abs(y[0]);
	else			last_y = y[0];
	
	return last_y;
}

/******************************
explanation
	移動平均後の y を出力.
******************************/
double IIR_2::get_y()
{
	return last_y;
}

/******************************
description
	_xを入力し、1次のIIR filterを通った後のy[0]まで算出.
******************************/
double IIR_1::x_in(double _x)
{
	/********************
	********************/
	for(int i = NUM_HISTORY - 1; 0 < i; i--){
		x[i] = x[i - 1];
		y[i] = y[i - 1];
	}
	x[0] = _x;
	y[0] = -Cb * y[1] + Cc * x[0] + Cd * x[1];
	
	/********************
	********************/
	if(Is_move_ave)	last_y = (1 - k_ave) * last_y + k_ave * abs(y[0]);
	else			last_y = y[0];
	
	return last_y;
}

/******************************
explanation
	移動平均後の y を出力.
******************************/
double IIR_1::get_y()
{
	return last_y;
}

